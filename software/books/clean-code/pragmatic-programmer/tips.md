# tips

1. care about your craft

2. think! about york work

3. provide options, don't make lame excuses

4. dont live with Broken Windows
  - people lose the will to fight entropy cus they perceive that no one else cares

5. be a catalyst for change (soldiers, stone soup)

6. remember the big picture (from villager's side, boiling frog)
  - the frog does not notice the change

7. make quality a requirement issue (these are the faulty ones)

8. invest regularly in your knowledge portfolio

9. critically analyze what you read and hear

10. it is both what you say and the way you say it

11. DRY - dont repeat yourself

12. make it easy to reuse (otherwise people wont reuse)

13. eliminiate effects between unrelated things (orthogonality)

14. there are no final decisions (reversibility)

15. use tracer bullets to find the target

16. prototype to learn

17. program close to the problem domain (domain language, DDD)

18. estimate to avoid surprises

19. iterate the schedule with the code

20. keep knowledge in plain text

21. use the power of command shells

22. use a single editor well

23. always use source code control

24. fix the problem, not the blame

25. dont panic (first rule of debugging)

26. "select" is NOT broken (insisting system call is wrong instead of application code)

27. dont assume it, prove it

28. learn a text manipulation language

29. write code that writes code

30. you can't write perfect software

31. design with contacts (pre-post conditions)

32. crash early

33. if it cannot happen, use assertions to ensure that it wont

34. use exceptions for exceptional problems

35. finish what you start (allocate, use, deallocate)

36. minimize coupling between modules (law of demeter)

37. configure, dont integrate (metaprogramming)

38. put abstractions in code, details in metadata

39. analyze workflow to improve concurrency

40. design using services (hungry consumer model)

41. always design for concurrency

42. separate views from models

43. use blackboards to coordinate workflows (detectives' board)

44. dont program by coincidence

45. estimate the order of your algorithms

46. test your estimates (code profilers)

47. refactor early, refactor often

48. design to test

49. test your software, or your users will

50. dont use wizard code you dont understand

51. dont gather requirements -- dig for them

52. work with a user to think like a user

53. abstractions live longer than details

54. use a project glossary

55. dont think outside the box -- find the box

56. listen to nagging doubts -- start when you are ready

57. some things are better done than described

58. dont be a slave to formal methods

59. expensive tools do not produce better designs

60. organize around functionality, not job functions

61. dont use manual procedures

62. test early. test often. test automatically

63. coding aint done til all the tests run

64. use saboteurs to test your testing

65. test state coverate, not code coverage (4 / 2, 4 / 0)

66. find bugs once (write test for the bug once found)

67. treat english as just another programming language

68. build documentation in, dont bolt it on

69. gently exceed your users' expectations

70. sign your work
